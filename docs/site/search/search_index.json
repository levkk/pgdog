{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PgDog","text":"<p>PgDog is a PostgreSQL query router, pooler, proxy and load balancer written in Rust. Spiritual successor to pgcat, PgDog comes with a lot of similar features, better performance, and introduces new features like plugins and cross-shard queries.</p> <p>PostgreSQL deployments of any size can be proxied by PgDog, ranging from a single database to hundreds of primaries and replicas in a sharded configuration.</p>"},{"location":"#installation","title":"Installation","text":"<p>PgDog is easily compiled from source. Before proceeding, make sure you have the latest version of the Rust compiler, available from rust-lang.org.</p>"},{"location":"#checkout-the-code","title":"Checkout the code","text":"<p>PgDog source code can be downloaded from GitHub:</p> <pre><code>git clone https://github.com/levkk/pgdog &amp;&amp; \\\ncd pgdog\n</code></pre>"},{"location":"#compile-pgdog","title":"Compile PgDog","text":"<p>PgDog should be compiled in release mode to make sure you get all performance benefits. You can do this with Cargo:</p> <pre><code>cargo build --release\n</code></pre>"},{"location":"#configuration","title":"Configuration","text":"<p>PgDog is configured via two files:</p> <ul> <li><code>pgdog.toml</code> which contains general pooler settings and PostgreSQL server information</li> <li><code>users.toml</code> which contains passwords for users allowed to connect to the pooler</li> </ul> <p>The passwords are stored in a separate file to simplify deployments in environments where secrets can be safely encrypted, like Kubernetes or AWS EC2.</p> <p>Both files can to be placed in the current working directory (CWD) for PgDog to detect them. Alternatively, you can pass the <code>--config</code> and <code>--secrets</code> arguments with their locations when starting PgDog.</p>"},{"location":"#example-pgdogtoml","title":"Example <code>pgdog.toml</code>","text":"<p>Most PgDog configuration options have sensible defaults. This allows a basic primary-only configuration to be pretty short:</p> <pre><code>[general]\nhost = \"0.0.0.0\"\nport = 6432\n\n[[databases]]\nname = \"postgres\"\nhost = \"127.0.0.1\"\n</code></pre>"},{"location":"#example-userstoml","title":"Example <code>users.toml</code>","text":"<p>This configuration file contains a mapping between databases, users and passwords. Users not specified in this file won't be able to connect to PgDog:</p> <pre><code>[[users]]\nname = \"alice\"\ndatabase = \"postgres\"\npassword = \"hunter2\"\n</code></pre>"},{"location":"#launch-the-pooler","title":"Launch the pooler","text":"<p>Starting the pooler can be done by running the binary in <code>target/release</code> folder or with Cargo:</p> CommandOutput <pre><code>cargo run --release\n</code></pre> <pre><code>INFO \ud83d\udc15 PgDog 0.1.0\nINFO loaded pgdog.toml\nINFO loaded users.toml\nINFO loaded \"pgdog_routing\" plugin [1.0461ms]\nINFO \ud83d\udc15 PgDog listening on 0.0.0.0:6432\nINFO new server connection [127.0.0.1:5432]\n</code></pre>"},{"location":"#next-steps","title":"Next steps","text":"<ul> <li>Features</li> <li>Configuration</li> <li>Architecture</li> </ul>"},{"location":"about/","title":"About this project","text":""},{"location":"about/#contributions","title":"Contributions","text":"<p>Contributions in all forms are welcome. If you find a bug and want to provide a fix, feel free to submit a pull request directly, or open an issue. If you'd like to see or implement a new feature, please create an issue first to discuss.</p>"},{"location":"about/#license","title":"License","text":"<p>PgDog is free and open source software licensed under the AGPL-3.0 license. While often misunderstood, this license allows anyone to use PgDog internally without sharing source code or any other work related to PgDog operations.</p> <p>All plugins developed for PgDog can be licensed under any license you wish and distributed to anyone (or kept private).</p> <p>If you plan to offer PgDog as a public service (e.g. a database cloud offering), please make sure to share any modifications you make to PgDog source code, so the whole community can benefit from your knowledge and expertise.</p>"},{"location":"about/#project-name","title":"Project name","text":"<p>This project is dedicated to the bestest dog in the world who's been patiently sitting at my feet the entire time PgDog has been developed.</p>"},{"location":"administration/","title":"Administration overview","text":"<p>PgDog keeps track of clients, servers and connection pools. It provides real time statistics on its internal operations for system administrators to keep track of and integrate with monitoring tools like Datadog.</p> <p>Just like pgbouncer, PgDog has a special \"admin\" database clients can connect to and run custom SQL commands to get statistics.</p>"},{"location":"administration/#admin-database","title":"Admin database","text":"<p>The admin database name is configurable. By default, the database is called <code>admin</code>. It supports a number of commands, documented below.</p>"},{"location":"administration/#commands","title":"Commands","text":"Command Description <code>SHOW CLIENTS</code> Clients connected to PgDog with real time statistics. <code>SHOW SERVERS</code> Server connections made by PgDog to PostgreSQL. <code>SHOW POOLS</code> Connection pools used to multiplex clients and servers. <code>SHOW CONFIG</code> Currently loaded values from <code>pgdog.toml</code>. <code>SHOW PEERS</code> List of PgDog processes running on the same network. Requires service discovery to be enabled. <code>RELOAD</code> Reload configuration from disk. See pgdog.toml and users.toml for which options can be changed at runtime. <code>RECONNECT</code> Re-create all server connections using existing configuration. <code>PAUSE</code> Pause all pools. Clients will wait for connections until pools are resumed. Can be used for gracefully restarting PostgreSQL servers. <code>RESUME</code> Resume all pools. Clients are able to check out connections again."},{"location":"administration/#shutting-down-pgdog","title":"Shutting down PgDog","text":"<p>When you need to shutdown PgDog, e.g. to deploy a new version, you can do so gracefully by issuing <code>SIGINT</code> (e.g. Ctrl-C) to the <code>pgdog</code> process. PgDog will stop listening for new connections and give connected clients some time to finish their transactions and disconnect.</p> <p>The amount of time PgDog will wait is configurable. By default, PgDog will wait 60 seconds.</p>"},{"location":"administration/#example","title":"Example","text":"<pre><code>$ pkill pgdog -SIGINT\n</code></pre>"},{"location":"administration/clients/","title":"Clients","text":"<p><code>SHOW CLIENTS</code> is a command to show currently connected clients and their real time statistics like number of queries/transactions executed, network activity, and state. For example:</p> <pre><code>admin=&gt; \\x\nExpanded display is on.\n\nadmin=&gt; SHOW CLIENTS;\n-[ RECORD 1 ]----+----------\nhost             | 127.0.0.1\nport             | 60798\nstate            | active\nqueries          | 2\ntransactions     | 2\nwait_time        | 0.00000\nquery_time       | 0.09521\ntransaction_time | 0.09624\nbytes_received   | 57\nbytes_sent       | 965\nerrors           | 0\n</code></pre>"},{"location":"administration/clients/#statistics","title":"Statistics","text":"Name Description <code>host</code> IP address of the client. <code>port</code> TCP port client is connected from. <code>state</code> Real time client state, e.g. <code>active</code>, <code>idle</code>, etc. <code>queries</code> Number of queries executed. <code>transactions</code> Number of completed transactions executed. <code>wait_time</code> How long the client had to wait to get a connection from the pool. This value increases monotonically if the client is waiting for a pool that's too busy to serve transactions. <code>query_time</code> Total time this client's queries took to run on a server. <code>transaction_time</code> Total time this client's transactions took to execute on the server, including idle in transaction time. <code>bytes_sent</code> Number of bytes sent over the network to the client. <code>bytes_received</code> Number of bytes received over the network from the client. <code>errors</code> Number of errors the client has received, e.g. query syntax errors."},{"location":"administration/config/","title":"Config","text":"<p><code>SHOW CONFIG</code> is a command to show currently loaded values from <code>pgdog.toml</code>. For example:</p> <pre><code>admin=&gt; SHOW CONFIG;\n           name            |     value\n---------------------------+----------------\n ban_timeout               | 5m\n default_pool_size         | 10\n healthcheck_interval      | 30s\n host                      | 0.0.0.0\n idle_healthcheck_delay    | 5s\n idle_healthcheck_interval | 30s\n load_balancing_strategy   | random\n min_pool_size             | 1\n pooler_mode               | transaction\n port                      | 6432\n rollback_timeout          | 5s\n shutdown_timeout          | 5s\n tls_certificate           | not configured\n tls_private_key           | not configured\n workers                   | 2\n(15 rows)\n</code></pre>"},{"location":"administration/pools/","title":"Pools","text":"<p><code>SHOW POOLS</code> is a command to show real time statistics on connection pools used to multiplex PgDog clients and PostgreSQL servers. For example:</p> <pre><code>admin=&gt; \\x\nExpanded display is on.\n\nadmin=&gt; SHOW POOLS;\n-[ RECORD 1 ]---+--------------\nhost            | 127.0.0.1\nport            | 5432\ndatabase        | pgdog\nuser            | pgdog\nidle            | 1\nactive          | 0\ntotal           | 1\nclients_waiting | 0\npaused          | f\nbanned          | f\nerrors          | 0\nout_of_sync     | 0\n-[ RECORD 2 ]---+--------------\nhost            | 127.0.0.1\nport            | 5432\ndatabase        | pgdog\nuser            | pgdog_session\nidle            | 1\nactive          | 0\ntotal           | 1\nclients_waiting | 0\npaused          | f\nbanned          | f\nerrors          | 0\nout_of_sync     | 0\n</code></pre>"},{"location":"administration/pools/#statistics","title":"Statistics","text":"Name Description <code>host</code> IP address or DNS name of the PostgreSQL server. <code>port</code> TCP port of the PostgreSQL server. <code>database</code> Name of the PostgreSQL database. <code>user</code> User used to connect to the database. <code>idle</code> Number of idle server connections in the pool. <code>active</code> Number of checked out (used) server connections in the pool. <code>total</code> Total number of server connections in the pool. <code>clients_waiting</code> Number of clients waiting for a connection from this pool. <code>paused</code> The pool is paused and won't issue connections until resumed. <code>banned</code> The pool is blocked from serving more clients. <code>errors</code> Number of connections returned to the pool in a bad state, e.g. network connectivity broken. <code>out_of_sync</code> Number of connections returned to the pool by clients that left it in a bad state, e.g. by issuing a query and not waiting for the result."},{"location":"administration/servers/","title":"Servers","text":"<p><code>SHOW SERVERS</code> is a command to show real time statistics on PostgreSQL server connections created by connection pools. For example:</p> <pre><code>admin=&gt; \\x\nExpanded display is on.\n\nadmin=&gt; SHOW SERVERS;\n-[ RECORD 1 ]-------+----------\nhost                | 127.0.0.1\nport                | 5432\nstate               | idle\ntransactions        | 58\nqueries             | 58\nrollbacks           | 0\nprepared_statements | 0\nhealthchecks        | 58\nerrors              | 0\nbytes_received      | 638\nbytes_sent          | 406\nage                 | 1719733\n-[ RECORD 2 ]-------+----------\nhost                | 127.0.0.1\nport                | 5432\nstate               | idle\ntransactions        | 58\nqueries             | 58\nrollbacks           | 0\nprepared_statements | 0\nhealthchecks        | 58\nerrors              | 0\nbytes_received      | 638\nbytes_sent          | 406\nage                 | 1719734\n</code></pre>"},{"location":"administration/servers/#statistics","title":"Statistics","text":"Name Description <code>host</code> IP address or DNS name of the server. <code>port</code> TCP port of the server. <code>state</code> Server connection state, e.g. <code>active</code>, <code>idle in transaction</code>, etc. <code>transactions</code> Number of transactions completed by this server connection. <code>queries</code> Number of queries executed by this server connection. <code>rollbacks</code> Number of automatic rollbacks executed on this server connection by PgDog to clean up after idle transactions left by clients. <code>prepared_statements</code> Number of prepared statements created on this server connection. <code>healthchecks</code> Number of healthchecks executed on this server connection. <code>errors</code> Number of errors this connection has produced e.g. syntax errors. <code>bytes_received</code> Number of bytes received over the network. <code>bytes_sent</code> Number of bytes sent over the network. <code>age</code> How long ago this connection was created (in ms)."},{"location":"architecture/","title":"Architecture overview","text":"<p>PgDog is written in the Rust programming language. It is also asynchronous, powered by the Tokio runtime. This allows PgDog to serve hundreds of thousands of connections on one machine and to take advantage of multiple CPUs.</p>"},{"location":"architecture/#plugins","title":"Plugins","text":"<p>Plugins are shared libraries (<code>.so</code> on Linux, <code>.dylib</code> on Mac, <code>.dll</code> on Windows) loaded at startup. This allows to change many aspects of PgDog functionality without altering or recompiling internal source code.</p>"},{"location":"architecture/#postgresql-protocol","title":"PostgreSQL protocol","text":"<p>PgDog speaks the PostgreSQL frontend/backend protocol. This allows it to act as an application layer (OSI Level 7) proxy and multiplex client/server connections. It can also alter connection state to suit operational needs, e.g. rolling back unfinished transactions, changing server settings, clearing session variables.</p>"},{"location":"architecture/#learn-more","title":"Learn more","text":"<ul> <li>Features</li> <li>Configuration</li> <li>Benchmarks</li> </ul>"},{"location":"architecture/benchmarks/","title":"Benchmarks","text":"<p>PgDog does its best to minimize its impact on database performance. Great care is taken to make sure as few operations are possible are performed when passing data between clients and servers. All benchmarks listed below were done on my local system and should be taken with a grain of salt. Real world performance is impacted by factors like network speed, query complexity and especially by hardware used for running PgDog and PostgreSQL servers.</p>"},{"location":"architecture/benchmarks/#pgbench","title":"pgbench","text":"<p>The simplest way to test PostgreSQL performance is with <code>pgbench</code>. It comes standard with all PostgreSQL installations (Mac and Linux):</p> <pre><code>$ pgbench --version\npgbench (PostgreSQL) 16.4 (Postgres.app)\n</code></pre> <p>A standard pgBench benchmark will run <code>INSERT</code>, <code>UPDATE</code>, <code>SELECT</code> and <code>DELETE</code> queries to get an overall view of database performance. Since we are only testing the performance of PgDog, we are going to run <code>SELECT</code> queries only and minimize the impact of hard disk I/O on this test.</p> <p>This benchmark can be reproduced by passing the <code>-S</code> flag to <code>pgbench</code>. The results below were performed using the configuration found in <code>pgdog.toml</code>.</p>"},{"location":"architecture/benchmarks/#results","title":"Results","text":"<p>Numbers below are for a single primary benchmark in transaction mode. No plugins are in use and PgDog is configured to use only 1 CPU core (<code>workers = 0</code>).</p> Clients Throughput (/s) Latency 1 17,865.08 0.056 ms 10 70,770.09 0.136 ms 100 54,649.23 1.686 ms"},{"location":"architecture/benchmarks/#with-pgdog-routing-enabled","title":"With <code>pgdog-routing</code> enabled","text":"<p>These results are with <code>pgdog_routing</code> plugin enabled and parsing all queries with <code>pg_query.rs</code>. Parsing queries has some noticeable overhead. Enabling multi-threading improved performance by over 50% in some cases.</p> Clients Throughput (/s) Average latency Workers 1 12,902.98 0.077 ms 0 10 35,861.21 0.269 ms 0 100 32,982.90 2.733 ms 0 1 14229.39 0.070 ms 2 10 52379.48 0.136 ms 2 100 57657.4 1.723 ms 4"},{"location":"architecture/benchmarks/#interpretation","title":"Interpretation","text":""},{"location":"architecture/benchmarks/#1-client","title":"1 client","text":"<p>Benchmarks with <code>-c 1</code> (1 client) are a good baseline for what's possible under the best possible circumstances. There is no contention on resources and PgDog effectively receives data in one socket and pushes it out the other.</p>"},{"location":"architecture/benchmarks/#10-clients","title":"10 clients","text":"<p>With 10 clients actively querying the database, the connection pool is at full capacity. While there are no clients waiting for connections, the pool has to serve clients without any slack in the system. This benchmark should produce the highest throughput numbers.</p>"},{"location":"architecture/benchmarks/#100-clients","title":"100 clients","text":"<p>With over 10x more clients connected than available servers, connections are fighting for resources and PgDog has to make sure everyone gets served in a fair way. Consistent throughput in this benchmark demonstrates our ability to timeshare server connections effectively.</p>"},{"location":"architecture/benchmarks/#in-the-real-world","title":"In the real world","text":"<p>In production, PostgreSQL clients are expected to be mostly idle. For example, web applications spend a lot of their time parsing HTTP requests, running code and waiting on network I/O. This leaves plenty of time for PgDog (and PostgreSQL) to serve queries for thousands of clients.</p>"},{"location":"architecture/benchmarks/#hardware-impact","title":"Hardware impact","text":"<p>Benchmark results will vary widely with hardware. For example, these numbers will be better on new Apple M chips and slower on older Intel CPUs. This benchmark was ran on the Apple M1 chip. Expect yours to vary, but the overall trend to be directionally similar.</p>"},{"location":"architecture/benchmarks/#pgbench-configuration","title":"pgbench configuration","text":"<pre><code>export PGPASSWORD=pgdog\npgbench -P 1 -h 127.0.0.1 -p 6432 -U pgdog pgdog -c 10 -t 100000 -S\n</code></pre>"},{"location":"configuration/","title":"Configuration overview","text":"<p>PgDog uses the TOML configuration language for its two configuration files: <code>pgdog.toml</code> and <code>users.toml</code>. Both are required for PgDog to run, but most settings are optional with sane defaults, so a basic PgDog deployment requires very little work to configure.</p> <p>By default, PgDog looks for both configuration files in the current working directory. Alternatively, you can pass <code>--config=&lt;path&gt;</code> and <code>--users=&lt;path&gt;</code> arguments to PgDog on startup.</p>"},{"location":"configuration/#hot-reload","title":"Hot reload","text":"<p>Most settings can be reloaded without restarting PgDog. This allows to tweak them at runtime without breaking client or server connections. For settings that require a restart, a note is added to the documentation.</p>"},{"location":"configuration/#units","title":"Units","text":"<p>To make things simpler, all units of time are in milliseconds. For example, if you want to set the pool checkout timeout to 5 seconds, convert it to 5000ms instead:</p> <pre><code>checkout_timeout = 5_000\n</code></pre> <p>Since PgDog uses TOML, both <code>5000</code> and <code>5_000</code> are valid numbers. Configuration will fail to load if non-integer values are used, e.g. \"5s\" or \"53.5\".</p>"},{"location":"configuration/#overview","title":"Overview","text":"Name Description General General pooler settings like <code>host</code>, <code>port</code> and various timeouts. Databases PostgreSQL databases proxied by PgDog. Plugins Plugins configuration. Users List of users (with passwords) that are allowed to connect to PgDog. Admin Admin database settings like admin password."},{"location":"configuration/pgdog.toml/admin/","title":"Admin database settings","text":"<p>Admin database settings control access to the admin database which contains real time statistics about internal operations of PgDog. For example:</p> <pre><code>[admin]\npassword = \"hunter2\"\n</code></pre>"},{"location":"configuration/pgdog.toml/admin/#name","title":"<code>name</code>","text":"<p>Admin database name.</p> <p>Default: <code>admin</code></p>"},{"location":"configuration/pgdog.toml/admin/#user","title":"<code>user</code>","text":"<p>User allowed to connect to the admin database. This user doesn't have to be configured in <code>users.toml</code>.</p> <p>Default: <code>admin</code></p>"},{"location":"configuration/pgdog.toml/admin/#password","title":"<code>password</code>","text":"<p>Password the user needs to provide when connecting to the admin database. By default, this is randomly generated so the admin database is locked out unless this value is set.</p> <p>Note</p> <p>If this value is not set, admin database access will be restricted.</p> <p>Default: random</p>"},{"location":"configuration/pgdog.toml/databases/","title":"Database settings","text":"<p>Database settings configure which databases PgDog is proxying. This is a TOML list of hosts, ports, and other settings like database roles (primary or replica). For each database host, add a <code>[[databases]]</code> entry to <code>pgdog.toml</code>. For example:</p> <pre><code>[[databases]]\nname = \"prod\"\nhost = \"10.0.0.1\"\nport = 5432\n\n[[databases]]\nname = \"prod\"\nhost = \"10.0.0.2\"\nport = 5432\nrole = \"replica\"\n</code></pre>"},{"location":"configuration/pgdog.toml/databases/#name","title":"<code>name</code>","text":"<p>Name of your database. Clients that connect to PgDog will need to use this name to refer to the database. For multiple entries part of the same cluster, use the same <code>name</code>.</p> <p>Default: none (required)</p>"},{"location":"configuration/pgdog.toml/databases/#host","title":"<code>host</code>","text":"<p>IP address or DNS name of the machine where the PostgreSQL server is running. For example:</p> <ul> <li><code>10.0.0.1</code></li> <li><code>localhost</code></li> <li><code>prod-primary.local-net.dev</code></li> </ul> <p>Default: none (required)</p>"},{"location":"configuration/pgdog.toml/databases/#port","title":"<code>port</code>","text":"<p>The port PostgreSQL is running on. More often than not, this is going to be <code>5432</code>.</p> <p>Default: <code>5432</code></p>"},{"location":"configuration/pgdog.toml/databases/#role","title":"<code>role</code>","text":"<p>Type of role this host performs in your database cluster. This can be either <code>primary</code> for primary databases that serve writes (and reads), and <code>replica</code> for PostgreSQL replicas that can only serve reads.</p> <p>Default: <code>primary</code></p>"},{"location":"configuration/pgdog.toml/databases/#database_name","title":"<code>database_name</code>","text":"<p>Name of the PostgreSQL database on the server PgDog will connect to. If not set, this defaults to <code>name</code>.</p> <p>Default: none (defaults to <code>name</code>)</p>"},{"location":"configuration/pgdog.toml/databases/#user","title":"<code>user</code>","text":"<p>Name of the PostgreSQL user to connect with when creating backend connections from PgDog to Postgres. If not set, this defaults to <code>name</code> in <code>users.toml</code>. This setting is used to override <code>users.toml</code> configuration values.</p> <p>Default: none (see <code>users.toml</code>)</p>"},{"location":"configuration/pgdog.toml/databases/#password","title":"<code>password</code>","text":"<p>Password to use when creating backend connections to PostgreSQL. If not set, this defaults to <code>password</code> in <code>users.toml</code>. This setting is used to override <code>users.toml</code> configuration values.</p> <p>Default: none (see <code>users.toml</code>)</p>"},{"location":"configuration/pgdog.toml/general/","title":"General settings","text":"<p>General settings are relevant to the operations of the pooler itself, or apply to all database pools.</p>"},{"location":"configuration/pgdog.toml/general/#host","title":"<code>host</code>","text":"<p>The IP address of the local network interface PgDog will bind to listen for connections.</p> <p>Note</p> <p>This setting cannot be changed at runtime.</p> <p>Default: <code>0.0.0.0</code> (all interfaces)</p>"},{"location":"configuration/pgdog.toml/general/#port","title":"<code>port</code>","text":"<p>The TCP port PgDog will bind to listen for connections.</p> <p>Default: <code>6432</code></p> <p>Note</p> <p>This setting cannot be changed at runtime.</p>"},{"location":"configuration/pgdog.toml/general/#workers","title":"<code>workers</code>","text":"<p>Number of Tokio threads to spawn at pooler startup. In multi-core systems, the recommended setting is two (2) per virtual CPU. The value <code>0</code> means to spawn no threads and use the current thread runtime (single-threaded). The latter option is better on IO-bound systems where multi-threading is not necessary and could even hamper performance.</p> <p>Default: <code>0</code> (current thread runtime)</p> <p>Note</p> <p>This setting cannot be changed at runtime.</p>"},{"location":"configuration/pgdog.toml/general/#default_pool_size","title":"<code>default_pool_size</code>","text":"<p>Default maximum number of server connections per database pool. The pooler will not open more than this many PostgreSQL database connections when serving clients.</p> <p>Default: <code>10</code></p>"},{"location":"configuration/pgdog.toml/general/#min_pool_size","title":"<code>min_pool_size</code>","text":"<p>Default minimum number of connections per database pool to keep open at all times. Keeping some connections open minimizes cold start time when clients connect to the pooler for the first time.</p> <p>Default: <code>1</code></p>"},{"location":"configuration/pgdog.toml/general/#pooler_mode","title":"<code>pooler_mode</code>","text":"<p>Default pooler mode to use for database pools. See Transaction mode and session mode for more details on each mode.</p> <p>Default:  <code>transaction</code></p>"},{"location":"configuration/pgdog.toml/general/#tls","title":"TLS","text":""},{"location":"configuration/pgdog.toml/general/#tls_certificate","title":"<code>tls_certificate</code>","text":"<p>Path to the TLS certificate PgDog will use to setup TLS connections with clients. If none is provided, TLS will be disabled.</p> <p>Default: none</p> <p>Note</p> <p>This setting cannot be changed at runtime.</p>"},{"location":"configuration/pgdog.toml/general/#tls_private_key","title":"<code>tls_private_key</code>","text":"<p>Path to the TLS private key PgDog will use to setup TLS connections with clients. If none is provided, TLS will be disabled.</p> <p>Default: none</p> <p>Note</p> <p>This setting cannot be changed at runtime.</p>"},{"location":"configuration/pgdog.toml/general/#healthchecks","title":"Healthchecks","text":""},{"location":"configuration/pgdog.toml/general/#healthcheck_interval","title":"<code>healthcheck_interval</code>","text":"<p>Frequency of healthchecks performed by PgDog to ensure connections provided to clients from the pool are working.</p> <p>Default: <code>30_000</code> (30s)</p>"},{"location":"configuration/pgdog.toml/general/#idle_healthcheck_interval","title":"<code>idle_healthcheck_interval</code>","text":"<p>Frequency of healthchecks performed by PgDog on idle connections. This ensures the database is checked for health periodically when PgDog receives little to no client requests.</p> <p>Default: <code>30_000</code> (30s)</p>"},{"location":"configuration/pgdog.toml/general/#note-on-min_pool_size","title":"Note on <code>min_pool_size</code>","text":"<p>Healthchecks try to use existing idle connections to validate the database is up and running. If there are no idle connections available, PgDog will create an ephemeral connection to perform the healthcheck. If you want to avoid this, make sure to have <code>min_pool_size</code> to be at least <code>1</code>.</p>"},{"location":"configuration/pgdog.toml/general/#idle_healthcheck_delay","title":"<code>idle_healthcheck_delay</code>","text":"<p>Delay running idle healthchecks at PgDog startup to give databases (and pools) time to spin up.</p> <p>Default: <code>5_000</code> (5s)</p>"},{"location":"configuration/pgdog.toml/general/#timeouts","title":"Timeouts","text":"<p>These settings control how long PgDog waits for maintenance tasks to complete. These timeouts make sure PgDog can recover from abnormal conditions like hardware failure.</p>"},{"location":"configuration/pgdog.toml/general/#rollback_timeout","title":"<code>rollback_timeout</code>","text":"<p>How long to allow for <code>ROLLBACK</code> queries to run on server connections with unfinished transactions. See transaction mode for more details.</p> <p>Default: <code>5_000</code> (5s)</p>"},{"location":"configuration/pgdog.toml/general/#ban_timeout","title":"<code>ban_timeout</code>","text":"<p>Connectionn pools blocked from serving traffic due to an error will be placed back into active rotation after this long. This ensures that servers don't stay blocked forever due to healthcheck false positives.</p> <p>Default: <code>300_000</code> (5 minutes)</p>"},{"location":"configuration/pgdog.toml/general/#shutdown_timeout","title":"<code>shutdown_timeout</code>","text":"<p>How long to wait for active clients to finish transactions when shutting down. This ensures that PgDog redeployments disrupt as few queries as possible.</p> <p>Default: <code>60_000</code> (60s)</p>"},{"location":"configuration/pgdog.toml/general/#load-balancer","title":"Load balancer","text":""},{"location":"configuration/pgdog.toml/general/#load_balancing_strategy","title":"<code>load_balancing_strategy</code>","text":"<p>Which strategy to use for load balancing read queries. See load balancer for more details. Available options are:</p> <ul> <li><code>random</code></li> <li><code>least_active_connections</code></li> <li><code>round_robin</code></li> </ul> <p>Default: <code>random</code></p>"},{"location":"configuration/pgdog.toml/general/#service-discovery","title":"Service discovery","text":""},{"location":"configuration/pgdog.toml/general/#broadcast_address","title":"<code>broadcast_address</code>","text":"<p>Send multicast packets to this address on the local network. Configuring this setting enables mutual service discovery. Instances of PgDog running on the same network will be able to see each other.</p> <p>Default: unset</p>"},{"location":"configuration/pgdog.toml/general/#broadcast_port","title":"<code>broadcast_port</code>","text":"<p>The port used for sending and receiving broadcast messages.</p> <p>Default: <code>6433</code></p>"},{"location":"configuration/pgdog.toml/plugins/","title":"Plugin settings","text":"<p>Plugins are dynamically loaded at pooler startup. These settings control which plugins are loaded. In the future, more options will be available to configure plugin behavior.</p> <p>Plugins are a TOML list, so for each plugin you want to enable, add a <code>[[plugins]]</code> entry to <code>pgdog.toml</code>. For example:</p> <pre><code>[[plugins]]\nname = \"bob_router\"\n\n[[plugins]]\nname = \"alice_router\"\n</code></pre> <p>Note</p> <p>Plugins can only be configured at PgDog startup. They cannot be changed after the process is running.</p>"},{"location":"configuration/pgdog.toml/plugins/#name","title":"<code>name</code>","text":"<p>Name of the plugin to load. This is used by PgDog to look up the shared library object in <code>LD_LIBRARY_PATH</code>. For example, if your plugin name is <code>router</code>, PgDog will look for <code>librouter.so</code> on Linux, <code>librouter.dll</code> on Windows and <code>librouter.dylib</code> on Mac OS.</p>"},{"location":"configuration/users.toml/users/","title":"Users configuration","text":"<p>This configuration controls which users are allowed to connect to PgDog. This is a TOML list so for each user, add a <code>[[users]]</code> section to <code>users.toml</code>. For example:</p> <pre><code>[[users]]\nname = \"alice\"\ndatabase = \"prod\"\npassword = \"hunter2\"\n\n[[users]]\nname = \"bob\"\ndatabase = \"prod\"\npassword = \"opensesame\"\n</code></pre>"},{"location":"configuration/users.toml/users/#name","title":"<code>name</code>","text":"<p>Name of the user. Clients that connect to PgDog will need to use this username.</p> <p>Default: none (required)</p>"},{"location":"configuration/users.toml/users/#database","title":"<code>database</code>","text":"<p>Name of the database cluster this user belongs to. This refers to <code>name</code> setting in <code>pgdog.toml</code>, databases section.</p> <p>Default: none (required)</p>"},{"location":"configuration/users.toml/users/#password","title":"<code>password</code>","text":"<p>The password for the user. Clients will need to provide this when connecting to PgDog.</p> <p>Default: none (required)</p>"},{"location":"configuration/users.toml/users/#pool_size","title":"<code>pool_size</code>","text":"<p>Overrides <code>default_pool_size</code> for this user. No more than this many server connections will be open at any given time to serve requests for this connection pool.</p> <p>Default: none (defaults to <code>default_pool_size</code> from <code>pgdog.toml</code>)</p>"},{"location":"configuration/users.toml/users/#pooler_mode","title":"<code>pooler_mode</code>","text":"<p>Overrides <code>pooler_mode</code> for this user. This allows users in session mode to connect to the same PgDog instance as users in transaction mode.</p> <p>Default: none (defaults to <code>pooler_mode</code> from <code>pgdog.toml</code>)</p>"},{"location":"configuration/users.toml/users/#server_user","title":"<code>server_user</code>","text":"<p>Which user to connect with when creating backend connections from PgDog to PostgreSQL. By default, the user configured in <code>name</code> is used. This setting allows to override this configuration and use a different user.</p> <p>Note</p> <p>Values specified in <code>pgdog.toml</code> take priority over this configuration.</p> <p>Default: none (defaults to <code>name</code>)</p>"},{"location":"configuration/users.toml/users/#server_password","title":"<code>server_password</code>","text":"<p>Which password to connect with when creating backend connections from PgDog to PostgreSQL. By default, the password configured in <code>password</code> is used. This setting allows to override this configuration and use a different password, decoupling server passwords from user passwords given to clients.</p> <p>Default: none (defaults to <code>password</code>)</p> <p>Note</p> <p>Values specified in <code>pgdog.toml</code> take priority over this configuration.</p>"},{"location":"configuration/users.toml/users/#statement_timeout","title":"<code>statement_timeout</code>","text":"<p>Sets the <code>statement_timeout</code> on all server connections at connection creation. This allows to set a reasonable default for each user without modifying <code>postgresql.conf</code> or using <code>ALTER USER</code>.</p> <p>Note</p> <p>Nothing is preventing the user from manually changing this setting at runtime, e.g., by running <code>SET statement_timeout TO 0</code>;</p>"},{"location":"features/","title":"Features overview","text":"<p>PgDog contains multiple foundational and unique features which make it a great choice for modern PostgreSQL deployments.</p> <p>Most features are configurable and can be toggled and tuned. Experimental features are marked as such, and users are advised to test them before deploying to production. Most foundational features like load balancing, healthchecks, and query routing have been battle-tested and work well in production.</p>"},{"location":"features/#summary","title":"Summary","text":"<p>Note</p> <p>PgDog is just getting started and most features are incomplete. The documentation is sometimes written to reflect the desired state. In the case where the feature is not complete, a note is added to that effect.</p> Feature Description State Transaction mode Multiplex transactions and servers for busy PostgreSQL deployments. \u2714\ufe0f Good Load balancer Split query traffic evenly across multiple databases. \ud83d\udd28 Work in progress Healthchecks Periodically check databases to ensure they are up and can serve queries. \u2714\ufe0f Good Live configuration reloading Update configuration at runtime without having to restart PgDog. \ud83d\udd28 Work in progress Sharding Automatic query routing using a sharding key to scale writes horizontally. \ud83d\udd28 Work in progress Plugins Pluggable libraries to parse and route queries, loaded at runtime. \u2714\ufe0f Good Authentication Support for various PostgreSQL authentication mechanisms, e.g. <code>SCRAM-SHA-256</code>. \ud83d\udd28 Work in progress Session mode Compatibility mode with direct Postgres connections. \ud83d\udd28 Work in progress"},{"location":"features/#os-support","title":"OS support","text":"<p>PgDog doesn't use any OS-specific features and should run on all systems supported by the Rust compiler, e.g. Linux (x86 and ARM64), Mac OS, and Windows.</p>"},{"location":"features/authentication/","title":"Authentication","text":"<p>PostgreSQL servers support many authentication mechanisms. PgDog supports a subset of those, with the aim to support all of them over time. Since PostgreSQL 14, <code>SCRAM-SHA-256</code> is widely used to encrypt passwords and PgDog supports this algorithm for both client and server connections.</p> <p>Authentication is enabled by default. Applications connecting to PgDog must provide a username and password which is configured in <code>users.toml</code>. For connecting to PostgreSQL databases, PgDog currently supports only <code>SCRAM-SHA-256</code>.</p>"},{"location":"features/authentication/#add-users","title":"Add users","text":"<p><code>users.toml</code> follows a simple TOML list structure. To add users, simply add another <code>[[users]]</code> section, e.g.:</p> <pre><code>[[users]]\nname = \"pgdog\"\ndatabase = \"pgdog\"\npassword = \"hunter2\"\n</code></pre> <p>PgDog will expect clients connecting as <code>pgdog</code> to provide the password <code>hunter2</code> (hashed with <code>SCRAM-SHA-256</code>), and will use the same username and password to connect to PostgreSQL.</p>"},{"location":"features/authentication/#override-server-credentials","title":"Override server credentials","text":"<p>You can override the user and/or password PgDog uses to connect to Postgres by specifying <code>server_user</code> and <code>server_password</code> in the same configuration:</p> <pre><code>server_user = \"bob\"\nserver_password = \"opensesame\"\n</code></pre> <p>This allows to separate client and server credentials. In case your clients accidentally leak theirs, you only need to rotate them in the PgDog configuration, without having to take downtime to change passwords in PostgreSQL.</p>"},{"location":"features/authentication/#passthrough-authentication","title":"Passthrough authentication","text":"<p>Note</p> <p>This feature is a work in progress.</p> <p>Passthrough authentication is a feature where instead of storing passwords in <code>users.toml</code>, PgDog connects to the database server and queries it for the password stored in <code>pg_shadow</code>. It then matches this password to what the user supplied, and if they match, authorizes the connection.</p> <p>Passthrough authentication simplifies PgDog deployments by using a single source of truth for authentication.</p> <p>Currently, passthrough authentication is a work-in-progress. You can track progress in issue #6.</p>"},{"location":"features/authentication/#security","title":"Security","text":"<p>Since PgDog stores passwords in a separate configuration file, it's possible to encrypt it at rest without compromising the DevOps experience. For example, Kubernetes provides built-in secrets management to manage this.</p>"},{"location":"features/healthchecks/","title":"Healthchecks","text":"<p>Databases proxied by PgDog are regularly checked with healthchecks. A healthcheck is a simple query, e.g. <code>SELECT 1</code>, which ensures the database is reachable and able to answer requests.</p> <p>If a database fails a healthcheck, it's placed in a list of banned hosts. Banned databases are removed from the load balancer and will not serve transactions. This allows PgDog to reduce errors clients see when a database fails, for example due to hardware issues.</p> <p> <p>Replica failure</p> <p></p>"},{"location":"features/healthchecks/#configuration","title":"Configuration","text":"<p>Healthchecks are enabled by default and are used for all databases. Healthcheck interval is configurable on a global and database levels.</p> <p>The default healthcheck interval is 30 seconds.</p> <pre><code>[global]\nhealthcheck_interval = 30_000 # ms\n\n[[databases]]\nname = \"prod\"\nhealthcheck_interval = 60_000 # ms\n</code></pre>"},{"location":"features/healthchecks/#timeouts","title":"Timeouts","text":"<p>By default, PgDog gives the database 5 seconds to answer a healthcheck. If it doesn't receive a reply, the database will be banned from serving traffic for a configurable amount of time. Both the healthcheck timeout and the ban time are configurable.</p> <pre><code>[global]\nhealthcheck_timeout = 5_000 # 5 seconds\nban_timeout = 60_000 # 1 minute\n</code></pre>"},{"location":"features/healthchecks/#ban-expiration","title":"Ban expiration","text":"<p>By default, a ban has an expiration. Once the ban expires, the replica is unbanned and placed back into rotation. This is done to maintain a healthy level of traffic across all databases and to allow for intermittent issues, like network connectivity, to resolve themselves without manual intervention.</p>"},{"location":"features/healthchecks/#failsafe","title":"Failsafe","text":"<p>If all databases in a cluster are banned due to a healthcheck failure, PgDog assumes that healthchecks are returning incorrect information and unbans all databases in the cluster. This protects against false positives and ensures the cluster continues to serve traffic.</p>"},{"location":"features/healthchecks/#learn-more","title":"Learn more","text":"<ul> <li>Load balancer</li> </ul>"},{"location":"features/load-balancer/","title":"Load balancer","text":"<p>PgDog operates at the application layer (OSI Level 7) and is capable of load balancing queries across multiple PostgreSQL databases.</p> <p> </p>"},{"location":"features/load-balancer/#strategies","title":"Strategies","text":"<p>The load balancer is configurable and can route queries using one of several strategies:</p> <ul> <li>Random (default)</li> <li>Least active connections</li> <li>Round robin</li> </ul>"},{"location":"features/load-balancer/#random","title":"Random","text":"<p>Queries are sent to a database based using a random number generator modulus the number of replicas in the pool. This strategy is the simplest and often effective at splitting traffic evenly across the cluster. It's unbiased and assumes nothing about available resources or query performance.</p> <p>This strategy is used by default.</p>"},{"location":"features/load-balancer/#least-active-connections","title":"Least active connections","text":"<p>PgDog keeps track of how many active connections each database has and can route queries to databases which are least busy executing requests. This allows to \"bin pack\" the cluster based on how seemingly active (or inactive) the databases are.</p> <p>This strategy is useful when all databases have identical resources and all queries have roughly the same cost and runtime.</p>"},{"location":"features/load-balancer/#round-robin","title":"Round robin","text":"<p>This strategy is often used in HTTP load balancers like nginx to route requests to hosts in the same order they appear in the configuration. Each database receives exactly one query before the next one is used.</p> <p>This strategy makes the same assumptions as least active connections, except it makes no attempt to bin pack the cluster with workload and distributes queries evenly.</p>"},{"location":"features/load-balancer/#configuration","title":"Configuration","text":"<p>The load balancer is enabled automatically when a database cluster contains more than one database. For example:</p> <pre><code>[[databases]]\nname = \"prod\"\nrole = \"replica\"\nhost = \"10.0.0.1\"\n\n[[databases]]\nname = \"prod\"\nrole = \"replica\"\nhost = \"10.0.0.2\"\n</code></pre>"},{"location":"features/load-balancer/#learn-more","title":"Learn more","text":"<ul> <li>Healthchecks</li> </ul>"},{"location":"features/session-mode/","title":"Session mode","text":"<p>In session mode, PgDog allocates one PostgreSQL server connection per client. This ensures that all PostgreSQL features work as expected, including persistent session variables, settings, and process-based features like <code>LISTEN</code>/<code>NOTIFY</code>. Some batch-based tasks, like ingesting large amounts of data, perform better in session mode.</p>"},{"location":"features/session-mode/#enable-session-mode","title":"Enable session mode","text":"<p>Session mode can be enabled globally or on a per-user basis:</p> pgdog.tomlusers.toml <pre><code>[general]\npooler_mode = \"session\"\n</code></pre> <pre><code>[[users]]\nname = \"pgdog\"\ndatabase = \"pgdog\"\npooler_mode = \"session\"\n</code></pre>"},{"location":"features/session-mode/#performance","title":"Performance","text":"<p>Unlike transaction mode, session mode doesn't allow for client/server connection multiplexing, so the maximum number of allowed client connections is controlled by the <code>default_pool_size</code> (and <code>pool_size</code>) settings. For example, if your database pool size is 15, only 15 clients will be able to connect and use the database at any given moment.</p> <p>Note</p> <p>In session mode, when the connection pool reaches full capacity, a client has to disconnect before another one can connect to PgDog.</p>"},{"location":"features/session-mode/#benefits-of-session-mode","title":"Benefits of session mode","text":"<p>Using PgDog in session mode is still an improvement over connecting to PostgreSQL directly. Since the proxy maintains a pool of open server connections, when a client disconnects, the PostgreSQL server connection remains intact and can be reused by another client.</p>"},{"location":"features/session-mode/#lazy-connections","title":"Lazy connections","text":"<p>Until a client issues their first query, PgDog doesn't attach it to a server connection. This allows one set of clients to connect before the previous set disconnects, which is common when using zero-downtime deployment strategies like blue/green<sup>1</sup>.</p> <ol> <li> <p>https://docs.aws.amazon.com/whitepapers/latest/overview-deployment-options/bluegreen-deployments.html \u21a9</p> </li> </ol>"},{"location":"features/transaction-mode/","title":"Transaction mode","text":"<p>In transaction mode, PgDog is able to multiplex client transactions with several PostgreSQL backend servers. This allows the pooler to serve thousands of clients using only dozens of actual server connections. This feature is essential for at-scale PostgreSQL deployments since Postgres is not able to maintain more than a few thousand concurrently open connections.</p> <p> <p>In transaction mode, multiple clients can reuse one Postgres connection.</p> <p></p>"},{"location":"features/transaction-mode/#enable-transaction-mode","title":"Enable transaction mode","text":"<p>Transaction mode is enabled by default. This is controllable via configuration, at the global and user level:</p> pgdog.tomlusers.toml <pre><code>[general]\npooler_mode = \"transaction\"\n</code></pre> <pre><code>[[users]]\nname = \"alice\"\ndatabase = \"prod\"\npooler_mode = \"transaction\"\n</code></pre>"},{"location":"features/transaction-mode/#session-state","title":"Session state","text":"<p>Note</p> <p>This feature is a work in progress.</p> <p>Since clients in transaction mode reuse PostgreSQL server connections, it's possible for session-level variables and state to leak between clients. PgDog keeps track of connection state modifications and can automatically clean up server connections after a transaction. While this helps prevent session variables leakage between clients, this does have a small performance overhead.</p> <p>To avoid this, clients using PgDog in transaction mode should avoid the usage of <code>SET</code> statements and use <code>SET LOCAL</code> inside an explicit transaction instead:</p> <pre><code>BEGIN;\nSET LOCAL statement_timeout = '30s';\nSELECT * FROM my_table;\nCOMMIT;\n</code></pre>"},{"location":"features/plugins/","title":"Plugins overview","text":"<p>One of features that make PgDog particularly powerful is its plugin system. Users of PgDog can write plugins in any language and inject them inside the query router to direct query traffic, to rewrite queries, or to block them entirely and return custom results.</p>"},{"location":"features/plugins/#api","title":"API","text":"<p>PgDog plugins are shared libraries loaded at application startup. They can be written in any programming language, as long as that language can be compiled to a shared library, and can expose a predefined set of C ABI-compatible functions.</p>"},{"location":"features/plugins/#functions","title":"Functions","text":""},{"location":"features/plugins/#pgdog_init","title":"<code>pgdog_init</code>","text":"<p>This function is executed once when PgDog loads the plugin, at application startup. It allows to initialize any kind of internal plugin state. Execution of this function is synchronized, so it's safe to execute any thread-unsafe functions or initialize synchronization primitives, like mutexes.</p> <p>This function has the following signature:</p> RustC/C++ <pre><code>pub extern \"C\" fn pgdog_init() {}\n</code></pre> <pre><code>void pgdog_init();\n</code></pre>"},{"location":"features/plugins/#pgdog_route_query","title":"<code>pgdog_route_query</code>","text":"<p>This function is called every time the query router sees a new query and needs to figure out where this query should be sent. The query text and parameters will be provided and the router expects the plugin to parse the query and provide a route.</p> <p>This function has the following signature:</p> RustC/C++ <pre><code>use pgdog_plugin::*;\n\npub extern \"C\" fn pgdog_route_query(Input query) -&gt; Output {\n    Route::unknown()\n}\n</code></pre> <pre><code>Output pgdog_route_query(Input query);\n</code></pre>"},{"location":"features/plugins/#data-structures","title":"Data structures","text":"<p>This function expects an input of type <code>Input</code> and must return a struct of type <code>Output</code>. The input contains the query PgDog received and the current database configuration, e.g. number of shards, replicas, and if there is a primary database that can serve writes.</p> <p>The output structure contains the routing decision (e.g. query should go to a replica) and any additional information that the plugin wants to communicate, which depends on the routing decision. For example, if the plugin wants PgDog to intercept this query and return a custom result, rows of that result will be included in the output.</p>"},{"location":"features/plugins/#pgdog_fini","title":"<code>pgdog_fini</code>","text":"<p>This function is called before the pooler is shut down. This allows plugins to perform any tasks, like saving some internal state to a durable medium.</p> <p>This function has the following signature:</p> RustC/C++ <pre><code>pub extern \"C\" fn pgdog_fini() {}\n</code></pre> <pre><code>void pgdog_fini();\n</code></pre>"},{"location":"features/plugins/#examples","title":"Examples","text":"<p>Example plugins written in Rust and C are included in GitHub.</p>"},{"location":"features/plugins/#learn-more","title":"Learn more","text":"<ul> <li>Plugins in Rust</li> <li>Plugins in C</li> </ul>"},{"location":"features/plugins/c/","title":"Plugins in C","text":"<p>Writing PgDog plugins in C is pretty straight forward if you're comfortable in the language. The plugin API is written in C (for compatibility), so if you're comfortable in C, you should be right at home.</p>"},{"location":"features/plugins/c/#getting-started","title":"Getting started","text":""},{"location":"features/plugins/c/#includes","title":"Includes","text":"<p>The plugin headers are located in <code>pgdog-plugin/include</code>. Include <code>pgdog.h</code> for everything you need to get started:</p> <pre><code>#include \"pgdog.h\"\n</code></pre>"},{"location":"features/plugins/c/#linking","title":"Linking","text":"<p>Your plugin will use <code>pgdog-plugin</code> internals, so you need to link to it at build time. To do so, first compile <code>pgdog-plugin</code> by running this command in the root directory of the project:</p> <pre><code>cargo build\n</code></pre> <p>This ensures all libraries and bindings are compiled before you get started.</p> <p>Note</p> <p>If you're writing plugins for release (<code>-02</code>), build the crate using the release profile by passing <code>--release</code> flag to Cargo.</p> <p>The shared library will be placed in <code>target/(debug|release)</code> and you can link to it like so:</p> <pre><code>export LIBRARY_PATH=target/debug\ngcc plugin.c -lpgdog_routing -lshared -o plugin.so\n</code></pre>"},{"location":"features/plugins/c/#memory-safety","title":"Memory safety","text":"<p>All structures passed to plugins are owned by PgDog runtime, so make sure not to <code>free</code> any pointers. All structures passed back to PgDog will be freed automatically by PgDog, so you don't need to worry about leaks.</p> <p>If you allocate any memory during routine execution, make sure to free it before you return from the plugin API call.</p>"},{"location":"features/plugins/c/#globals","title":"Globals","text":"<p>Access to <code>pgdog_route_query</code> is not synchronized, so if you use any globals, make sure they are static or protected by a mutex. You can initialize any globals in <code>pgdog_init</code> and clean them up in <code>pgdog_fini</code>.</p>"},{"location":"features/plugins/c/#learn-more","title":"Learn more","text":"<ul> <li>routing-plugin-c example plugin</li> </ul> <p>See Rust documentation for how to implement plugins.</p>"},{"location":"features/plugins/rust/","title":"Plugins in Rust","text":"<p>Writing PgDog plugins in Rust has first class support built into the <code>pgdog-plugin</code> crate. The crate acts as a bridge between plugins and PgDog internals, and provides safe methods for constructing C-compatible structs.</p>"},{"location":"features/plugins/rust/#how-it-works","title":"How it works","text":"<p>For plugins to be truly dynamic, they have to be compiled into shared libraries (<code>.so</code> on Linux, <code>.dylib</code> on Mac). This way you can load arbitrary plugins into PgDog at runtime without having to recompile it. Since Rust doesn't have a stable ABI, we have to use the only stable ABI available to all programming languages: C.</p>"},{"location":"features/plugins/rust/#c-abi","title":"C ABI","text":"<p>Rust has great bindings for using (and exposing) C-compatible functions. You can learn more about this by reading the <code>std::ffi</code> documentation and other great sources like The Embedded Rust Book<sup>1</sup>.</p> <p>The <code>pgdog-plugin</code> crate contains C headers that define types and functions PgDog expects its plugins to use, with Rust bindings generated with bindgen.</p>"},{"location":"features/plugins/rust/#getting-started","title":"Getting started","text":"<p>Create a new library crate with Cargo, like so:</p> <pre><code>cargo new --lib my_pgdog_plugin\n</code></pre> <p>Since plugins have to be C ABI compatible, you'll need to change the crate type to <code>cdylib</code> (C dynamic library). Edit your <code>Cargo.toml</code> and add the following:</p> <pre><code>[lib]\ncrate-type = [\"rlib\", \"cdylib\"]\n</code></pre>"},{"location":"features/plugins/rust/#add-pgdog-plugin","title":"Add <code>pgdog-plugin</code>","text":"<p>To make building plugins easier, PgDog provides a crate that defines and implements the structs used by plugin functions.</p> <p>Before proceeding, add this crate to your dependencies:</p> <pre><code>cargo add pgdog-plugin\n</code></pre>"},{"location":"features/plugins/rust/#implement-the-api","title":"Implement the API","text":"<p>The plugin API is pretty simple. For this tutorial, we'll implement the query routing function <code>pgdog_route_query</code>, which is called for the first query in every transaction PgDog receives.</p> <p>This function has the following signature:</p> <pre><code>use pgdog_plugin::*;\n\npub extern \"C\" fn pgdog_route_query(input: Input) -&gt; Output {\n  todo!()\n}\n</code></pre> <p>The <code>Input</code> structure contains the query PgDog received and the current state of the pooler configuration, like the number of shards, the number of replicas and their addresses, and other information which the plugin can use to determine where the query should go.</p> <p>The plugin is expected to return an <code>Output</code> structure which contains its routing decision and any additional data the plugin wants PgDog to use, like an error it wants PgDog to return to the client instead, for example.</p> <p>Both structures have Rust implementations which can help us avoid having to write C-like initialization code.</p>"},{"location":"features/plugins/rust/#parse-the-input","title":"Parse the input","text":"<p>You can get the query PgDog received from the input structure like so:</p> <pre><code>if let Some(query) = input.query() {\n  // Parse the query.\n}\n</code></pre> <p>The query is a Rust string, so your routing algorithm can be as simple as:</p> <pre><code>let route = if query.starts_with(\"SELECT\") {\n  // Route this to any replica.\n  Route::read_any()\n} else {\n  // Send the query to a primary.\n  Route::write_any()\n}\n</code></pre> <p>Both <code>read_any</code> and <code>write_any</code> are typically used in a single shard configuration and tell PgDog that the shard number is not important. PgDog will send the query to the first shard in the configuration.</p>"},{"location":"features/plugins/rust/#return-the-output","title":"Return the output","text":"<p>The <code>Output</code> structure contains the routing decision and any additional metadata. Since our plugin parsed the query and decided to forward this query to a database without modifications, the return value for <code>Output</code> should be:</p> <pre><code>return Output::forward(route)\n</code></pre> <p>Not all plugins have to make a routing decision. For example, if your plugin just wants to count how many queries of a certain type your database receives but doesn't care about routing, you can tell PgDog to skip your plugin's routing decision:</p> <pre><code>return Output::skip()\n</code></pre> <p>PgDog will ignore this output and pass the query to the next plugin in the chain.</p>"},{"location":"features/plugins/rust/#parsing-query-parameters","title":"Parsing query parameters","text":"<p>PostgreSQL protocol has two ways to send queries to the database: using the simple query method with the parameters included in the query text, and the extended protocol which sends parameters separately to prevent SQL injection attacks and allow for query re-use (prepared statements).</p> <p>The extended protocol is widely used, so queries your plugins will see will typically look like this:</p> <pre><code>SELECT * FROM users WHERE id = $1\n</code></pre> <p>If your plugin is sharding requests based on a hash (or some other function) of the <code>\"users\".\"id\"</code> column, you need to see the value of <code>$1</code> before your plugin can make a decision.</p> <p>PgDog supports parsing the extended protocol and provides the full query text and parameters to its plugins. You can access a specific parameter by calling <code>Query::parameter</code>:</p> <pre><code>if let Some(id) = query.parameter(0) {\n  // Parse the parameter.\n}\n</code></pre> <p>Note</p> <p>PostgreSQL uses a lot of 1-based indexing, e.g. parameters and arrays start at 1. PgDog is more \"rusty\" and uses 0-based indexing. To access the first parameter in a query, index it by <code>0</code>, not <code>1</code>.</p> <p>Parameters are encoded using PostgreSQL wire protocol, so they can be either UTF-8 text or binary. If they are text, which is often the case, you can access it like so:</p> <pre><code>if let Some(id) = id.as_str() {\n  let id = id.parse::&lt;i64&gt;();\n}\n</code></pre> <p>In the case of binary encoding, <code>as_str()</code> will return <code>None</code> and you can parse the binary encoding instead:</p> <pre><code>if let Ok(id) = id.as_bytes().try_into() {\n  let id = i64::from_be_bytes(id);\n}\n</code></pre> <p>While this may seem tedious at first, this provides the highest flexibility for parsing parameters. A plugin can use any kind of field for routing, e.g. cosine similarity of a vector column (to another), which requires parsing vector-encoded fields.</p> <p>Note</p> <p>As the project evolves, I expect we'll add more helpers to the <code>pgdog-plugin</code> crate to help parse parameters automatically.</p>"},{"location":"features/plugins/rust/#sql-parsers","title":"SQL parsers","text":"<p>Parsing SQL manually can be error-prone, and there are multiple great SQL parsers you can pick off the shelf. The pgdog-routing plugin which ships with PgDog uses <code>pg_query.rs</code>, which in turn uses the internal PostgreSQL query parser. This ensures all valid PostgreSQL queries are recognized and parsed correctly.</p> <p>Other SQL parsers in the Rust community include sqlparser which can parse many dialects, including other databases like MySQL, if you wanted to rewrite MySQL queries to PostgreSQL queries transparently for example.</p>"},{"location":"features/plugins/rust/#handling-errors","title":"Handling errors","text":"<p>Since plugins use the C ABI, PgDog is not able to catch panics inside plugins. Therefore, if a plugin panics, this will cause an abort and shutdown the pooler.</p> <p>The vast majority of the Rust standard library and crates avoid panicking and return errors instead. Plugin code must check for error conditions and handle them internally. Notably, don't use <code>unwrap()</code> on <code>Option</code> or <code>Result</code> types and handle each case instead.</p> <p>Note</p> <p>Better error handling is on the roadmap, e.g. by using macros that wrap plugin code into a panic handler. That being said, since plugins do expose <code>extern \"C\"</code> functions, this limitation should be explicitely stated to plugin authors.</p>"},{"location":"features/plugins/rust/#learn-more","title":"Learn more","text":"<p>PgDog plugins are in their infancy and many more features will be added over time. For now, the API is pretty bare bones but can already do useful things. Our bundled plugin we use for routing is called pgdog-routing and it can be used as the basis for your plugin development.</p> <ol> <li> <p>https://docs.rust-embedded.org/book/interoperability/rust-with-c.html \u21a9</p> </li> </ol>"},{"location":"features/sharding/","title":"Sharding overview","text":"<p>Note</p> <p>This feature is under active development. It's not ready production use.</p> <p>Sharding PostgreSQL databases involves splitting the database between multiple machines and routing queries to the right machines using a sharding function. Like its predecessor, PgDog supports sharded PostgreSQL deployments and can route queries to the correct shards automatically, implemented as a plugin.</p> <p> <p>Sharded database routing.</p> </p>"},{"location":"features/sharding/#architecture","title":"Architecture","text":"<p>There are two ways for database clients to query sharded databases: by connecting to specific shard, or by querying all shards and aggregating the results. The former is commonly used in OLTP (transactional) systems, e.g. real time applications, and the latter is more commonly used in OLAP (analytical) databases, e.g. batch reports generation.</p> <p>PgDog has good support for single shard queries, and adding support for aggregates over time<sup>1</sup>.</p>"},{"location":"features/sharding/#sql-parser","title":"SQL parser","text":"<p>The <code>pgdog-routing</code> plugin parses queries using <code>pg_query</code> and can calculate the shard based on a column value specified in the query. This allows applications to shard their databases without code modifications. For queries where this isn't possible, clients can specify the desired shard (or sharding key) in a query comment.</p>"},{"location":"features/sharding/#multi-shard-queries","title":"Multi-shard queries","text":"<p>When the sharding key isn't available or impossible to extract from a query, PgDog can route the query to all shards and return results combined in a single response. Clients using this feature are not aware they are communicating with a sharded database and can treat PgDog connections like normal.</p>"},{"location":"features/sharding/#learn-more","title":"Learn more","text":"<ul> <li>Multi-shard queries</li> <li>Manual routing</li> </ul> <ol> <li> <p>Aggregation can get pretty complex and sometimes requires query rewriting. Examples can be found in the PostgreSQL's postgres_fdw extension.\u00a0\u21a9</p> </li> </ol>"},{"location":"features/sharding/automatic-routing/","title":"Automatic query routing","text":"<p>Note</p> <p>This documentation is a work in progress. Check back soon for updates.</p>"},{"location":"features/sharding/automatic-routing/#learn-more","title":"Learn more","text":"<ul> <li>Multi-shard queries</li> <li>Manual routing</li> </ul>"},{"location":"features/sharding/copy/","title":"Sharded COPY","text":"<p>Note</p> <p>Support for the <code>COPY</code> command and automatic sharding is a work in progress.</p>"},{"location":"features/sharding/cross-shard/","title":"Cross-shard queries","text":"<p>If a client can't or chooses not to provide a sharding key, PgDog can route the query to all shards and combine the results transparently. To the client, this feels like the query executed against a single database.</p> <p> <p>A query executed across all 3 shards.</p> </p>"},{"location":"features/sharding/cross-shard/#architecture","title":"Architecture","text":"<p>Since PgDog speaks the Postgres protocol, it can connect to multiple database servers and collect <code>DataRow</code><sup>1</sup> messages as they are being sent by each server. Once all servers finish executing the query, PgDog processes the result and sends it to the client as if all messages came from one server.</p> <p>While this works for simple queries, others that involve sorting or aggregation are more complex and require special handling.</p>"},{"location":"features/sharding/cross-shard/#sorting","title":"Sorting","text":"<p>If the client requests results to be ordered by one or more columns, PgDog can interpret this request and perform the sorting once it receives all data messages from Postgres. For queries that span multiple shards, this feature allows to retrieve results in the correct order. For example:</p> <pre><code>SELECT *\nFROM users\nWHERE admin IS true\nORDER BY id DESC;\n</code></pre> <p>This query has no sharding key, so PgDog will send it to all shards in parallel. Once all shards receive the query, they will filter data from their respective <code>\"users\"</code> table and send the results ordered by the <code>\"id\"</code> column.</p> <p>PgDog will receive rows from all shards at the same time, however Postgres is not aware of other shards in the system so the overall sorting order will be wrong. PgDog will collect all rows, and sort them by the <code>\"id\"</code> column before sending the results over to the client.</p> <p>Two kinds of sorting is supported:</p> <ul> <li>Order by column name(s)</li> <li>Order by column index</li> </ul>"},{"location":"features/sharding/cross-shard/#order-by-column-name","title":"Order by column name","text":"<p>PgDog can extract the column name(s) from the <code>ORDER BY</code> clause of a query and match them to values in <code>DataRow</code><sup>1</sup> messages based on their position in the <code>RowDescription</code><sup>1</sup> message received as the query starts executing on the shards.</p> <p>For example, if the query specifies <code>ORDER BY id ASC, email DESC</code>, both <code>\"id\"</code> and <code>\"email\"</code> columns will be present in the <code>RowDescription</code> message along with their data types and locations in <code>DataRow</code><sup>1</sup> messages.</p> <p>Once the messages are buffered in PgDog, it will sort them using the data extracted from messages and return the sorted result to the client.</p>"},{"location":"features/sharding/cross-shard/#example","title":"Example","text":"<pre><code>SELECT id, email, created_at\nFROM users\nORDER BY id, created_at\n</code></pre>"},{"location":"features/sharding/cross-shard/#order-by-column-index","title":"Order by column index","text":"<p>If the client specifies only the position of the column used in sorting, e.g., <code>ORDER BY 1 ASC, 4 DESC</code>, the mechanism for extracting data from rows is the same, except this time we don't need to look up column(s) by name: we have their position in the <code>RowDescription</code><sup>1</sup> message from the query.</p> <p>The rest of the process is identical and results are returned in the correct order to the client.</p>"},{"location":"features/sharding/cross-shard/#example_1","title":"Example","text":"<pre><code>SELECT id, email, created_at\nFROM users\nORDER BY 1, 3\n</code></pre>"},{"location":"features/sharding/cross-shard/#ddl","title":"DDL","text":"<p>DDL statements, i.e., queries that modify the database schema like <code>CREATE TABLE</code>, are sent to all shards simultaneously. This allows clients to modify all shard schemas at the same time and requires no special changes to systems used for schema management (e.g., migrations).</p> <p>This assumes that all shards in the cluster have an identical schema. This is typically desired to make management of sharded databases simpler, but in cases where this is not possible, DDL queries can always be routed to specific shards using manual routing.</p> <ol> <li> <p>PostgreSQL message formats \u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"features/sharding/manual-routing/","title":"Manual routing","text":"<p>In cases where the sharding key is not obvious or can't be extracted from the query, PgDog supports extracting it from a query comment. For example:</p> <pre><code>/* pgdog_shard: 1 */ SELECT * FROM users WHERE email = $1\n</code></pre> <p>will be routed to the second shard in the configuration.</p>"},{"location":"features/sharding/manual-routing/#syntax","title":"Syntax","text":"<p>Either the shard or the sharding key can be specified in a comment. To specify a shard number directly, write it like so:</p> <pre><code>/* pgdog_shard: &lt;number&gt; */\n</code></pre> <p>where <code>&lt;number&gt;</code> is the shard number, starting at 0. This annotation can be placed anywhere in the query, or be added to an existing comment.</p>"},{"location":"features/sharding/manual-routing/#sharding-key","title":"Sharding key","text":"<p>Note</p> <p>This feature is not built yet. It requires an implementation of a sharding function first.</p> <p>If you don't know the shard number but have a sharding key, e.g., the value of a column used for sharding your database, you can specify it in a comment as well:</p> <pre><code>/* pgdog_sharding_key: &lt;value&gt; */\n</code></pre> <p>PgDog will extract this value from the query and apply a sharding function to find out the actual shard number.</p>"},{"location":"features/sharding/manual-routing/#usage-in-frameworks","title":"Usage in frameworks","text":"<p>Some web frameworks support adding comments to queries easily. For example, if you're using Rails, you can add a comment like so:</p> RailsQuery <pre><code>User\n  .where(email: \"test@test.com\")\n  .annotate(\"pgdog_shard: 0\")\n  .to_sql\n</code></pre> <pre><code>SELECT \"users\".* FROM \"users\" WHERE \"email\" = $1 /* pgdog_shard: 0 */\n</code></pre> <p>Others make it pretty difficult, but still possible. For example, Laravel has a plugin to make it work while SQLAlchemy makes you write some code.</p> <p>For this reason, it's best to use automatic routing as much as possible.</p>"},{"location":"features/sharding/sharding-functions/","title":"Sharding functions","text":"<p>Note</p> <p>This section is a work in progress. Come back soon!</p>"}]}